<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Entropy Bus</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(to bottom, #87CEEB 0%, #87CEEB 60%, #228B22 60%, #228B22 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        #gameContainer {
            width: 90vw;
            max-width: 1200px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        #gameCanvas {
            display: block;
            width: 100%;
            background: linear-gradient(to bottom, #87CEEB 0%, #87CEEB 50%, #696969 50%, #696969 60%, #228B22 60%);
        }
        #ui {
            padding: 20px;
            background: #333;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        .stat {
            font-size: 18px;
            font-weight: bold;
        }
        .label {
            color: #FFD700;
            margin-right: 5px;
        }
        #entropyBar {
            flex: 1;
            min-width: 200px;
            height: 30px;
            background: #555;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }
        #entropyFill {
            height: 100%;
            background: linear-gradient(90deg, #FF4444, #FFAA00, #44FF44);
            width: 0%;
            transition: width 0.1s;
        }
        #entropyText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px black;
        }
        #instructions {
            text-align: center;
            padding: 15px;
            background: #f0f0f0;
            font-size: 16px;
        }
        #gameOver {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 10;
        }
        #gameOver h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #FFD700;
        }
        #gameOver button {
            font-size: 20px;
            padding: 15px 30px;
            margin-top: 20px;
            background: #FFD700;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        #gameOver button:hover {
            background: #FFA500;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="instructions">
            üöå <strong>ENTROPY BUS</strong> - Use ALL your keys! Letters, numbers, symbols, everything! More variety = More speed!
        </div>
        <canvas id="gameCanvas" width="1200" height="400"></canvas>
        <div id="ui">
            <div class="stat">
                <span class="label">Distance:</span>
                <span id="distance">0</span>m / 1000m
            </div>
            <div id="entropyBar">
                <div id="entropyFill"></div>
                <div id="entropyText">Entropy: 0%</div>
            </div>
            <div class="stat">
                <span class="label">Time:</span>
                <span id="time">0.0</span>s
            </div>
            <div class="stat">
                <span class="label">Unique Keys:</span>
                <span id="uniqueKeys">0</span> / 50+
            </div>
        </div>
        <div id="gameOver">
            <h1>üèÅ FINISH! üèÅ</h1>
            <p style="font-size: 24px; margin: 10px 0;">Time: <span id="finalTime"></span>s</p>
            <p style="font-size: 18px; margin: 10px 0;">Average Speed: <span id="avgSpeed"></span> km/h</p>
            <button onclick="restartGame()">Race Again</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameState = {
            distance: 0,
            velocity: 0,
            time: 0,
            maxDistance: 1000,
            keyPresses: [],
            keyFrequency: {},
            lastKeyTime: 0,
            gameStarted: false,
            gameFinished: false
        };

        // Constants
        const FRICTION = 0.96;
        const MAX_VELOCITY = 15;
        const ENTROPY_DECAY = 0.98;
        const TIME_WINDOW = 4000; // 4 seconds window
        const MIN_KEYS_FOR_MAX_ENTROPY = 50; // Need variety across entire keyboard
        let allKeysPressed = new Set(); // Track all unique keys ever pressed

        function calculateEntropy() {
            const now = Date.now();
            // Filter recent key presses
            gameState.keyPresses = gameState.keyPresses.filter(kp => now - kp.time < TIME_WINDOW);
            
            if (gameState.keyPresses.length < 5) return 0;
            
            // Count unique keys
            const keySet = new Set(gameState.keyPresses.map(kp => kp.key));
            const uniqueKeys = keySet.size;
            const totalPresses = gameState.keyPresses.length;
            
            // Heavy penalty for low variety
            if (uniqueKeys < 5) return 0.05;
            if (uniqueKeys < 10) return 0.15;
            
            // Calculate frequency distribution
            const freq = {};
            gameState.keyPresses.forEach(kp => {
                freq[kp.key] = (freq[kp.key] || 0) + 1;
            });
            
            // Shannon entropy calculation
            let entropy = 0;
            for (let key in freq) {
                const p = freq[key] / totalPresses;
                entropy -= p * Math.log2(p);
            }
            
            // Normalize by maximum possible entropy
            const maxPossibleEntropy = Math.log2(uniqueKeys);
            let normalizedEntropy = maxPossibleEntropy > 0 ? entropy / maxPossibleEntropy : 0;
            
            // Very steep diversity penalty - need nearly full keyboard
            const diversityRatio = uniqueKeys / MIN_KEYS_FOR_MAX_ENTROPY;
            const diversityPenalty = Math.pow(diversityRatio, 2.5); // Much steeper
            
            // Detect repeating patterns
            let patternPenalty = 1.0;
            const recentKeys = gameState.keyPresses.slice(-15).map(kp => kp.key);
            
            // Check for sequential runs (asdf, qwer, etc)
            let sequentialCount = 0;
            for (let i = 1; i < recentKeys.length; i++) {
                const diff = Math.abs(recentKeys[i].charCodeAt(0) - recentKeys[i-1].charCodeAt(0));
                if (diff === 1) sequentialCount++;
            }
            if (sequentialCount > 2) patternPenalty *= 0.5;
            
            // Check for alternating patterns (ababab)
            let alternatingCount = 0;
            for (let i = 2; i < recentKeys.length; i++) {
                if (recentKeys[i] === recentKeys[i-2]) alternatingCount++;
            }
            if (alternatingCount > 3) patternPenalty *= 0.6;
            
            // Check for repeated bigrams (thth, erer)
            const bigrams = {};
            for (let i = 1; i < recentKeys.length; i++) {
                const bigram = recentKeys[i-1] + recentKeys[i];
                bigrams[bigram] = (bigrams[bigram] || 0) + 1;
            }
            const maxBigramCount = Math.max(...Object.values(bigrams));
            if (maxBigramCount > 2) patternPenalty *= 0.7;
            
            // Penalize uneven distribution - check if any key is overused
            const maxFreq = Math.max(...Object.values(freq));
            const evenness = 1 - (maxFreq / totalPresses);
            const evennessBonus = Math.pow(evenness, 2);
            
            // Press rate matters but much less
            const pressDuration = gameState.keyPresses.length > 1 ? 
                (gameState.keyPresses[gameState.keyPresses.length - 1].time - gameState.keyPresses[0].time) : 1;
            const pressRate = (totalPresses / pressDuration) * 1000;
            const rateMultiplier = Math.min(pressRate / 10, 1.1); // Very small bonus
            
            const finalEntropy = normalizedEntropy * diversityPenalty * patternPenalty * evennessBonus * rateMultiplier;
            return Math.min(finalEntropy, 1);
        }

        function handleKeyPress(e) {
            if (gameState.gameFinished) return;
            
            const now = Date.now();
            if (!gameState.gameStarted) {
                gameState.gameStarted = true;
            }
            
            // Track all keys pressed (including special keys, numbers, symbols)
            const key = e.key.length === 1 ? e.key : e.code; // Use code for special keys
            allKeysPressed.add(key);
            
            // Record key press
            gameState.keyPresses.push({
                key: key,
                time: now
            });
            
            // Calculate entropy and boost velocity
            const entropy = calculateEntropy();
            const velocityBoost = entropy * 0.8; // Up to 0.8 units per press
            gameState.velocity = Math.min(gameState.velocity + velocityBoost, MAX_VELOCITY);
            
            gameState.lastKeyTime = now;
        }

        function drawBus(x, y) {
            // Bus body
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(x, y, 80, 40);
            
            // Windows
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(x + 10, y + 5, 15, 15);
            ctx.fillRect(x + 30, y + 5, 15, 15);
            ctx.fillRect(x + 50, y + 5, 15, 15);
            
            // Wheels
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(x + 20, y + 40, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 60, y + 40, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Details
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(x + 70, y + 15, 8, 8);
        }

        function drawRoad() {
            // Road
            ctx.fillStyle = '#696969';
            ctx.fillRect(0, 200, canvas.width, 100);
            
            // Road lines
            ctx.fillStyle = '#FFD700';
            const lineOffset = (gameState.distance * 5) % 60;
            for (let i = -lineOffset; i < canvas.width; i += 60) {
                ctx.fillRect(i, 245, 40, 5);
            }
            
            // Grass
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, 300, canvas.width, 100);
        }

        function drawClouds() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            const cloudOffset = (gameState.distance * 2) % canvas.width;
            
            for (let i = 0; i < 3; i++) {
                const x = (i * 400 - cloudOffset + canvas.width) % canvas.width;
                ctx.beginPath();
                ctx.arc(x, 50 + i * 30, 30, 0, Math.PI * 2);
                ctx.arc(x + 25, 50 + i * 30, 35, 0, Math.PI * 2);
                ctx.arc(x + 50, 50 + i * 30, 30, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawFinishLine() {
            // Calculate finish line position based on distance
            // When distance = 0, finish is far right
            // When distance = maxDistance, finish is at bus position
            const progress = gameState.distance / gameState.maxDistance;
            const finishX = canvas.width + 200 - (progress * (canvas.width + 200 - 150)); // Moves from far right to bus X position
            
            // Always draw if within reasonable view
            if (finishX > -50) {
                ctx.fillStyle = '#000';
                ctx.fillRect(finishX, 200, 10, 100);
                ctx.fillStyle = '#FFF';
                for (let i = 0; i < 10; i++) {
                    if (i % 2 === 0) {
                        ctx.fillRect(finishX, 200 + i * 10, 10, 10);
                    }
                }
                
                // Draw "FINISH" text above the line
                if (finishX < canvas.width && finishX > -50) {
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('FINISH', finishX + 5, 190);
                }
            }
        }

        function update(deltaTime) {
            if (!gameState.gameStarted || gameState.gameFinished) return;
            
            gameState.time += deltaTime;
            
            // Apply friction
            gameState.velocity *= FRICTION;
            
            // Update distance
            gameState.distance += gameState.velocity;
            
            // Check for finish
            if (gameState.distance >= gameState.maxDistance) {
                gameState.distance = gameState.maxDistance;
                gameState.gameFinished = true;
                showGameOver();
            }
            
            // Update UI
            document.getElementById('distance').textContent = Math.floor(gameState.distance);
            document.getElementById('time').textContent = (gameState.time / 1000).toFixed(1);
            document.getElementById('uniqueKeys').textContent = allKeysPressed.size;
            
            const entropy = calculateEntropy();
            const entropyPercent = Math.floor(entropy * 100);
            document.getElementById('entropyFill').style.width = entropyPercent + '%';
            document.getElementById('entropyText').textContent = `Entropy: ${entropyPercent}%`;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Sky
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, 200);
            
            drawClouds();
            drawRoad();
            
            // Always draw finish line (it moves with distance)
            drawFinishLine();
            
            drawBus(150, 220);
        }

        function showGameOver() {
            const avgSpeed = (gameState.distance / (gameState.time / 1000) * 0.02).toFixed(1);
            document.getElementById('finalTime').textContent = (gameState.time / 1000).toFixed(2);
            document.getElementById('avgSpeed').textContent = avgSpeed;
            document.getElementById('gameOver').style.display = 'block';
        }

        function restartGame() {
            gameState = {
                distance: 0,
                velocity: 0,
                time: 0,
                maxDistance: 1000,
                keyPresses: [],
                keyFrequency: {},
                lastKeyTime: 0,
                gameStarted: false,
                gameFinished: false
            };
            allKeysPressed = new Set();
            document.getElementById('gameOver').style.display = 'none';
        }

        // Game loop
        let lastTime = Date.now();
        function gameLoop() {
            const now = Date.now();
            const deltaTime = now - lastTime;
            lastTime = now;
            
            update(deltaTime);
            draw();
            
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.addEventListener('keydown', handleKeyPress);
        
        // Start game loop
        gameLoop();
    </script>
</body>
</html>
