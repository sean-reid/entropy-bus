<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Entropy Bus</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(to bottom, #87CEEB 0%, #87CEEB 60%, #228B22 60%, #228B22 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            padding: 10px;
        }
        #gameContainer {
            width: 100%;
            max-width: 1200px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            overflow: hidden;
            position: relative;
        }
        #gameCanvas {
            display: block;
            width: 100%;
            height: auto;
            background: linear-gradient(to bottom, #87CEEB 0%, #87CEEB 50%, #696969 50%, #696969 60%, #228B22 60%);
        }
        #ui {
            padding: 15px;
            background: #333;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        .stat {
            font-size: 14px;
            font-weight: bold;
            white-space: nowrap;
        }
        .label {
            color: #FFD700;
            margin-right: 5px;
        }
        #entropyBar {
            flex: 1;
            min-width: 150px;
            width: 100%;
            height: 30px;
            background: #555;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }
        #entropyFill {
            height: 100%;
            background: linear-gradient(90deg, #FF4444, #FFAA00, #44FF44);
            width: 0%;
            transition: width 0.1s;
        }
        #entropyText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            font-size: 12px;
            color: white;
            text-shadow: 1px 1px 2px black;
        }
        #instructions {
            text-align: center;
            padding: 12px;
            background: #f0f0f0;
            font-size: 14px;
            line-height: 1.4;
        }
        #mobileControls {
            display: none;
            padding: 10px;
            background: #444;
            text-align: center;
        }
        #tapArea {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        #tapArea:active {
            transform: scale(0.95);
        }
        #gameOver {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 10;
            max-width: 90%;
        }
        #gameOver h1 {
            font-size: 36px;
            margin-bottom: 15px;
            color: #FFD700;
        }
        #gameOver p {
            font-size: 18px;
            margin: 8px 0;
        }
        #gameOver button {
            font-size: 18px;
            padding: 12px 25px;
            margin-top: 15px;
            background: #FFD700;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        #gameOver button:hover {
            background: #FFA500;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 0;
            }
            #gameContainer {
                border-radius: 0;
                max-width: 100%;
            }
            #instructions {
                font-size: 12px;
                padding: 10px;
            }
            .stat {
                font-size: 12px;
            }
            #ui {
                padding: 10px;
                gap: 8px;
            }
            #entropyBar {
                min-width: 120px;
            }
            #mobileControls {
                display: block;
            }
            #gameOver h1 {
                font-size: 28px;
            }
            #gameOver p {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="instructions">
            üöå <strong>ENTROPY BUS</strong> - <span id="desktopInstructions">Use ALL your keys! Letters, numbers, symbols, everything! More variety = More speed!</span><span id="mobileInstructions" style="display:none;">Tap the button below with random timing! Vary your rhythm for more speed!</span>
        </div>
        <canvas id="gameCanvas" width="1200" height="400"></canvas>
        <div id="mobileControls">
            <div id="tapArea">TAP TO ACCELERATE! üöåüí®</div>
        </div>
        <div id="ui">
            <div class="stat">
                <span class="label">Distance:</span>
                <span id="distance">0</span>m / 1000m
            </div>
            <div id="entropyBar">
                <div id="entropyFill"></div>
                <div id="entropyText">Entropy: 0%</div>
            </div>
            <div class="stat">
                <span class="label">Time:</span>
                <span id="time">0.0</span>s
            </div>
            <div class="stat" id="uniqueKeysDisplay">
                <span class="label">Unique Keys:</span>
                <span id="uniqueKeys">0</span> / 50+
            </div>
        </div>
        <div id="gameOver">
            <h1>üèÅ FINISH! üèÅ</h1>
            <p style="font-size: 24px; margin: 10px 0;">Time: <span id="finalTime"></span>s</p>
            <p style="font-size: 18px; margin: 10px 0;">Average Speed: <span id="avgSpeed"></span> km/h</p>
            <button onclick="restartGame()">Race Again</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameState = {
            distance: 0,
            velocity: 0,
            time: 0,
            maxDistance: 1000,
            keyPresses: [],
            keyFrequency: {},
            lastKeyTime: 0,
            gameStarted: false,
            gameFinished: false
        };

        // Constants
        const FRICTION = 0.96;
        const MAX_VELOCITY = 15;
        const TIME_WINDOW = 4000;
        const MIN_KEYS_FOR_MAX_ENTROPY = 50;
        let allKeysPressed = new Set();
        let isMobile = false;
        let tapTimings = [];

        function calculateEntropy() {
            const now = Date.now();
            
            if (isMobile) {
                tapTimings = tapTimings.filter(t => now - t < TIME_WINDOW);
                
                if (tapTimings.length < 5) return 0;
                
                const intervals = [];
                for (let i = 1; i < tapTimings.length; i++) {
                    intervals.push(tapTimings[i] - tapTimings[i-1]);
                }
                
                const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const variance = intervals.reduce((sum, interval) => {
                    return sum + Math.pow(interval - avgInterval, 2);
                }, 0) / intervals.length;
                
                const stdDev = Math.sqrt(variance);
                const normalizedEntropy = Math.min(stdDev / 200, 1);
                
                const tapDuration = tapTimings[tapTimings.length - 1] - tapTimings[0];
                const tapRate = (tapTimings.length / tapDuration) * 1000;
                const rateMultiplier = Math.min(tapRate / 5, 1.2);
                
                return Math.min(normalizedEntropy * rateMultiplier, 1);
            }
            
            gameState.keyPresses = gameState.keyPresses.filter(kp => now - kp.time < TIME_WINDOW);
            
            if (gameState.keyPresses.length < 5) return 0;
            
            const keySet = new Set(gameState.keyPresses.map(kp => kp.key));
            const uniqueKeys = keySet.size;
            const totalPresses = gameState.keyPresses.length;
            
            if (uniqueKeys < 5) return 0.05;
            if (uniqueKeys < 10) return 0.15;
            
            const freq = {};
            gameState.keyPresses.forEach(kp => {
                freq[kp.key] = (freq[kp.key] || 0) + 1;
            });
            
            let entropy = 0;
            for (let key in freq) {
                const p = freq[key] / totalPresses;
                entropy -= p * Math.log2(p);
            }
            
            const maxPossibleEntropy = Math.log2(uniqueKeys);
            let normalizedEntropy = maxPossibleEntropy > 0 ? entropy / maxPossibleEntropy : 0;
            
            const diversityRatio = uniqueKeys / MIN_KEYS_FOR_MAX_ENTROPY;
            const diversityPenalty = Math.pow(diversityRatio, 2.5);
            
            let patternPenalty = 1.0;
            const recentKeys = gameState.keyPresses.slice(-15).map(kp => kp.key);
            
            let sequentialCount = 0;
            for (let i = 1; i < recentKeys.length; i++) {
                const diff = Math.abs(recentKeys[i].charCodeAt(0) - recentKeys[i-1].charCodeAt(0));
                if (diff === 1) sequentialCount++;
            }
            if (sequentialCount > 2) patternPenalty *= 0.5;
            
            let alternatingCount = 0;
            for (let i = 2; i < recentKeys.length; i++) {
                if (recentKeys[i] === recentKeys[i-2]) alternatingCount++;
            }
            if (alternatingCount > 3) patternPenalty *= 0.6;
            
            const bigrams = {};
            for (let i = 1; i < recentKeys.length; i++) {
                const bigram = recentKeys[i-1] + recentKeys[i];
                bigrams[bigram] = (bigrams[bigram] || 0) + 1;
            }
            const maxBigramCount = Math.max(...Object.values(bigrams));
            if (maxBigramCount > 2) patternPenalty *= 0.7;
            
            const maxFreq = Math.max(...Object.values(freq));
            const evenness = 1 - (maxFreq / totalPresses);
            const evennessBonus = Math.pow(evenness, 2);
            
            const pressDuration = gameState.keyPresses.length > 1 ? 
                (gameState.keyPresses[gameState.keyPresses.length - 1].time - gameState.keyPresses[0].time) : 1;
            const pressRate = (totalPresses / pressDuration) * 1000;
            const rateMultiplier = Math.min(pressRate / 10, 1.1);
            
            const finalEntropy = normalizedEntropy * diversityPenalty * patternPenalty * evennessBonus * rateMultiplier;
            return Math.min(finalEntropy, 1);
        }

        function handleKeyPress(e) {
            if (gameState.gameFinished || isMobile) return;
            
            const now = Date.now();
            if (!gameState.gameStarted) {
                gameState.gameStarted = true;
            }
            
            const key = e.key.length === 1 ? e.key : e.code;
            allKeysPressed.add(key);
            
            gameState.keyPresses.push({
                key: key,
                time: now
            });
            
            const entropy = calculateEntropy();
            const velocityBoost = entropy * 0.8;
            gameState.velocity = Math.min(gameState.velocity + velocityBoost, MAX_VELOCITY);
            
            gameState.lastKeyTime = now;
        }

        function handleTap() {
            if (gameState.gameFinished) return;
            
            const now = Date.now();
            if (!gameState.gameStarted) {
                gameState.gameStarted = true;
            }
            
            tapTimings.push(now);
            allKeysPressed.add('tap_' + tapTimings.length);
            
            const entropy = calculateEntropy();
            const velocityBoost = entropy * 0.8;
            gameState.velocity = Math.min(gameState.velocity + velocityBoost, MAX_VELOCITY);
            
            gameState.lastKeyTime = now;
        }

        function drawBus(x, y) {
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(x, y, 80, 40);
            
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(x + 10, y + 5, 15, 15);
            ctx.fillRect(x + 30, y + 5, 15, 15);
            ctx.fillRect(x + 50, y + 5, 15, 15);
            
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(x + 20, y + 40, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 60, y + 40, 8, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(x + 70, y + 15, 8, 8);
        }

        function drawRoad() {
            ctx.fillStyle = '#696969';
            ctx.fillRect(0, 200, canvas.width, 100);
            
            ctx.fillStyle = '#FFD700';
            const lineOffset = (gameState.distance * 5) % 60;
            for (let i = -lineOffset; i < canvas.width; i += 60) {
                ctx.fillRect(i, 245, 40, 5);
            }
            
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, 300, canvas.width, 100);
        }

        function drawClouds() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            const cloudOffset = (gameState.distance * 2) % canvas.width;
            
            for (let i = 0; i < 3; i++) {
                const x = (i * 400 - cloudOffset + canvas.width) % canvas.width;
                ctx.beginPath();
                ctx.arc(x, 50 + i * 30, 30, 0, Math.PI * 2);
                ctx.arc(x + 25, 50 + i * 30, 35, 0, Math.PI * 2);
                ctx.arc(x + 50, 50 + i * 30, 30, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawFinishLine() {
            const progress = gameState.distance / gameState.maxDistance;
            const finishX = canvas.width + 200 - (progress * (canvas.width + 200 - 150));
            
            if (finishX > -50) {
                ctx.fillStyle = '#000';
                ctx.fillRect(finishX, 200, 10, 100);
                ctx.fillStyle = '#FFF';
                for (let i = 0; i < 10; i++) {
                    if (i % 2 === 0) {
                        ctx.fillRect(finishX, 200 + i * 10, 10, 10);
                    }
                }
                
                if (finishX < canvas.width && finishX > -50) {
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('FINISH', finishX + 5, 190);
                }
            }
        }

        function update(deltaTime) {
            if (!gameState.gameStarted || gameState.gameFinished) return;
            
            gameState.time += deltaTime;
            gameState.velocity *= FRICTION;
            gameState.distance += gameState.velocity;
            
            if (gameState.distance >= gameState.maxDistance) {
                gameState.distance = gameState.maxDistance;
                gameState.gameFinished = true;
                showGameOver();
            }
            
            document.getElementById('distance').textContent = Math.floor(gameState.distance);
            document.getElementById('time').textContent = (gameState.time / 1000).toFixed(1);
            document.getElementById('uniqueKeys').textContent = allKeysPressed.size;
            
            const entropy = calculateEntropy();
            const entropyPercent = Math.floor(entropy * 100);
            document.getElementById('entropyFill').style.width = entropyPercent + '%';
            document.getElementById('entropyText').textContent = `Entropy: ${entropyPercent}%`;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, 200);
            
            drawClouds();
            drawRoad();
            drawFinishLine();
            drawBus(150, 220);
        }

        function showGameOver() {
            const avgSpeed = (gameState.distance / (gameState.time / 1000) * 0.02).toFixed(1);
            document.getElementById('finalTime').textContent = (gameState.time / 1000).toFixed(2);
            document.getElementById('avgSpeed').textContent = avgSpeed;
            document.getElementById('gameOver').style.display = 'block';
        }

        function restartGame() {
            gameState = {
                distance: 0,
                velocity: 0,
                time: 0,
                maxDistance: 1000,
                keyPresses: [],
                keyFrequency: {},
                lastKeyTime: 0,
                gameStarted: false,
                gameFinished: false
            };
            allKeysPressed = new Set();
            tapTimings = [];
            document.getElementById('gameOver').style.display = 'none';
        }

        let lastTime = Date.now();
        function gameLoop() {
            const now = Date.now();
            const deltaTime = now - lastTime;
            lastTime = now;
            
            update(deltaTime);
            draw();
            
            requestAnimationFrame(gameLoop);
        }

        function detectMobile() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                       window.innerWidth < 768;
            
            if (isMobile) {
                document.getElementById('mobileInstructions').style.display = 'inline';
                document.getElementById('desktopInstructions').style.display = 'none';
                document.getElementById('uniqueKeysDisplay').style.display = 'none';
            } else {
                document.getElementById('mobileInstructions').style.display = 'none';
                document.getElementById('desktopInstructions').style.display = 'inline';
                document.getElementById('uniqueKeysDisplay').style.display = 'block';
            }
        }

        document.addEventListener('keydown', handleKeyPress);
        document.getElementById('tapArea').addEventListener('click', handleTap);
        document.getElementById('tapArea').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleTap();
        });
        
        detectMobile();
        window.addEventListener('resize', detectMobile);
        gameLoop();
    </script>
</body>
</html>
